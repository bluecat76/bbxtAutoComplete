#include "BBXTInterface.h"#define AC_MIN_TOKEN_LENGTH 3void processToken(CFStringRef text, CFStringRef token, CFRange token_range, CFIndex sel_start, CFMutableDictionaryRef word_list, CFStringRef *current_word){	// determine current word	if ((token_range.location < sel_start) && (token_range.location + token_range.length >= sel_start))	{		// current_word = CFStringCreateWithFormat(NULL, NULL, CFSTR("(%d, %d)"), token_range.location, token_range.length);		*current_word = CFStringCreateWithSubstring(NULL, text, CFRangeMake(token_range.location, sel_start-token_range.location));	}	else	{		// add token to word list if it is not already defined		if (CFStringGetLength(token) > AC_MIN_TOKEN_LENGTH)		{			CFDictionaryAddValue(word_list, token, NULL);		}	}}									pascal OSErr AutoComplete(BBXTCallbackBlock *callbacks, WindowRef window_ptr, long flags, AppleEvent* event, AppleEvent* reply){	#pragma unused(flags, event, reply)	OSErr result = noErr;	{		// Phase 1: read all tokens from current document, len>3 | OK!		// Phase 2: find out the word under the cursor and current selection		// Phase 3: filter out any tokens that do not begin with the current word		// Phase 4: present a selection to the user |ÊOK				// get document text		Handle text_handle;		Boolean multi_byte;		bbxtGetWindowText(callbacks, window_ptr, &text_handle, &multi_byte);				// define encoding (UTF16 if multi_byte), assume always!		CFStringEncoding encoding = kCFStringEncodingUTF16;				CFStringRef text = CFStringCreateWithBytes(NULL, *(UInt8 **)text_handle, GetHandleSize(text_handle), encoding, false);		// get current selected text part		CFIndex sel_start;		CFIndex sel_end;				bbxtGetSelection(callbacks, &sel_start, &sel_end, NULL);		CFStringRef sel_text = nil;		if (sel_end>sel_start)		{			sel_text = CFStringCreateWithSubstring(NULL, text, CFRangeMake(sel_start, sel_end-sel_start));		}		// tokenize document text by words		CFStringTokenizerRef tokenizer;		CFStringRef current_word = nil;		CFRange range = CFRangeMake(0, CFStringGetLength(text));		tokenizer = CFStringTokenizerCreate(NULL, text, range, kCFStringTokenizerUnitWordBoundary, CFLocaleCopyCurrent());		CFStringTokenizerTokenType token_type;		CFMutableDictionaryRef word_list = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks, NULL);				while (0 != (token_type = CFStringTokenizerAdvanceToNextToken(tokenizer)))		{			CFRange token_range = CFStringTokenizerGetCurrentTokenRange(tokenizer);			CFStringRef token = CFStringCreateWithSubstring(NULL, text, token_range);						// check if token begins with a LETTER to be valid!			CFIndex token_len = CFStringGetLength(token);			CFRange valid_range;			if (CFStringFindCharacterFromSet(token, CFCharacterSetGetPredefined(kCFCharacterSetLetter), CFRangeMake(0, token_len), kCFCompareAnchored, &valid_range))			{				CFArrayRef dot_occurences = CFStringCreateArrayWithFindResults(NULL, token, CFSTR("."), CFRangeMake(0, token_len), 0);				if (NULL != dot_occurences)				{					// find tokens separated by dot					CFIndex dot_count = CFArrayGetCount(dot_occurences);					CFIndex dot_index = 0;					CFIndex last_subtoken_start = 0;					CFIndex subtoken_len = 0;					CFStringRef subtoken = NULL;					do					{						CFRange *dot_range = (CFRange *)CFArrayGetValueAtIndex(dot_occurences, dot_index);						subtoken_len = dot_range->location;						subtoken = CFStringCreateWithSubstring(NULL, token, CFRangeMake(last_subtoken_start, subtoken_len));												processToken(text, subtoken, CFRangeMake(token_range.location + last_subtoken_start, subtoken_len), sel_start, word_list, &current_word);												CFRelease(subtoken);						last_subtoken_start = dot_range->location + 1;						dot_index++;					}					while(dot_index<dot_count);										// add last subtoken					subtoken_len = token_len - last_subtoken_start;					subtoken = CFStringCreateWithSubstring(NULL, token, CFRangeMake(last_subtoken_start, subtoken_len));					processToken(text, subtoken, CFRangeMake(token_range.location + last_subtoken_start, subtoken_len), sel_start, word_list, &current_word);					CFRelease(subtoken);										CFRelease(dot_occurences);				}				else				{					// add complete token					processToken(text, token, token_range, sel_start, word_list, &current_word);				}			}							CFRelease(token);		}				CFStringRef completion = nil;		if (nil != current_word)		{			// search for the next valid token			CFIndex count = CFDictionaryGetCount(word_list);			CFIndex index;			CFTypeRef *keysTypeRef = (CFTypeRef *)malloc(count * sizeof(CFTypeRef));			const void **keys = (const void **) keysTypeRef;			CFDictionaryGetKeysAndValues(word_list, keys, NULL);			CFStringRef first_token_found = nil;			Boolean selection_found = false;			for(index=0; index<count; index++)			{				CFStringRef token = keys[index];				CFRange find_range = CFStringFind(token, current_word, kCFCompareAnchored);				if (find_range.location != kCFNotFound)				{					// valid token					CFIndex part_length = CFStringGetLength(token) - find_range.length;										// ignore if current_word == token					if (part_length<=0)						continue;					CFStringRef token_part = CFStringCreateWithSubstring(NULL, token, CFRangeMake(find_range.length, CFStringGetLength(token) - find_range.length));										// set first find if empty					if (nil == first_token_found)					{						first_token_found = CFStringCreateCopy(NULL, token_part);												// if nothing is already selected, we are done						if (nil == sel_text)						{							CFRelease(token_part);							break;						}					}					if (selection_found)					{						// take the next token						completion = CFStringCreateCopy(NULL, token_part);						CFRelease(token_part);						break;					}					if (kCFCompareEqualTo == CFStringCompare(token_part, sel_text, 0))					{						// sel_text token found! Take the next valid token as next completion.						selection_found = true;					} 										CFRelease(token_part);				}			}			free(keys);						if (nil != first_token_found)			{				if (nil == completion)				{					completion = CFStringCreateCopy(NULL, first_token_found);				}								CFRelease(first_token_found);			}						CFRelease(current_word);		}		// write new selection text		if (nil != completion)		{			CFIndex completion_length = CFStringGetLength(completion);			CFIndex buf_len = CFStringGetMaximumSizeForEncoding(completion_length, encoding);			Handle buffer = NewHandle(buf_len);			if ((buffer==nil) || !CFStringGetBytes(completion, CFRangeMake(0, completion_length), encoding, 0, false, *(UInt8 **)buffer, buf_len, NULL))			{				result = memFullErr;			}			else 			{				result = bbxtReplaceSelection(callbacks, *buffer, completion_length, true);				bbxtSetSelection(callbacks, sel_start, sel_start + completion_length, -1);			}			if (nil != buffer) DisposeHandle(buffer);			CFRelease(completion);		}						// clean up		if (nil != sel_text) CFRelease(sel_text);		CFRelease(word_list);		CFRelease(tokenizer);		CFRelease(text);	}	return result;}